#include "model.hpp"
#include "constants.hpp"
#include "tensor_math.hpp"
#include <filesystem>

namespace fs = std::filesystem;

// 生成一个随机的四元数张量，用于初始化
torch::Tensor randomQuatTensor(long long n) {
  torch::Tensor u = torch::rand(n);
  torch::Tensor v = torch::rand(n);
  torch::Tensor w = torch::rand(n);
  return torch::stack({torch::sqrt(1 - u) * torch::sin(2 * PI * v),
                       torch::sqrt(1 - u) * torch::cos(2 * PI * v),
                       torch::sqrt(u) * torch::sin(2 * PI * w),
                       torch::sqrt(u) * torch::cos(2 * PI * w)},
                      -1);
}

// 创建一个OpenGL风格的透视投影矩阵
torch::Tensor projectionMatrix(float zNear, float zFar, float fovX, float fovY,
                               const torch::Device &device) {
  float t = zNear * std::tan(0.5f * fovY);
  float b = -t;
  float r = zNear * std::tan(0.5f * fovX);
  float l = -r;
  return torch::tensor({{2.0f * zNear / (r - l), 0.0f, (r + l) / (r - l), 0.0f},
                        {0.0f, 2 * zNear / (t - b), (t + b) / (t - b), 0.0f},
                        {0.0f, 0.0f, (zFar + zNear) / (zFar - zNear),
                         -2.0f * zFar * zNear / (zFar - zNear)},
                        {0.0f, 0.0f, 1.0f, 0.0f}},
                       device);
}

// 从PLY文件加载高斯模型
int Model::loadPly(const std::string &filename) {
  std::ifstream f(filename, std::ios::binary);
  if (!f.is_open())
    throw std::runtime_error("无法打开PLY文件: " + filename);

  std::string line;
  int step = 0;
  size_t bytesRead = 0;

  // 验证PLY文件头
  std::getline(f, line); // ply
  bytesRead += line.length() + 1;
  if (line.substr(0, 3) != "ply")
    throw std::runtime_error("无效的PLY文件：文件头不是'ply'");

  std::getline(f, line); // format
  bytesRead += line.length() + 1;
  if (line.find("binary_little_endian 1.0") == std::string::npos)
    throw std::runtime_error("仅支持 'binary_little_endian 1.0' 格式的PLY文件");

  // 读取注释和顶点元素信息
  int numPoints = 0;
  while (std::getline(f, line)) {
    bytesRead += line.length() + 1;
    if (line.find("element vertex") == 0) {
      numPoints = std::stoi(line.substr(15));
    } else if (line.find("comment Generated by opensplat at iteration") == 0) {
      step = std::stoi(line.substr(43));
    } else if (line.find("end_header") == 0) {
      break;
    }
  }

  if (numPoints == 0)
    throw std::runtime_error("PLY文件头中未找到顶点数量");

  // 重新打开文件并跳过头
  f.close();
  f.open(filename, std::ios::binary);
  f.seekg(bytesRead, std::ios::beg);

  // 根据属性数量计算每个点的大小
  // 基础属性: x, y, z, nx, ny, nz, opacity, scale_0, scale_1, scale_2, rot_0,
  // rot_1, rot_2, rot_3 (14 * float) SH属性: f_dc_ (3 * float), f_rest_ (45 *
  // float for degree 3)
  const int num_sh_features = numShBases(shDegree) - 1;
  const int features_dc_size = 3;
  const int features_rest_size = num_sh_features * 3;
  const size_t bytesPerPoint = sizeof(float) * (3 + 3 + features_dc_size +
                                                features_rest_size + 1 + 3 + 4);

  std::cout << "正在加载 " << numPoints << " 个高斯点..." << std::endl;

  // 为CPU张量分配内存
  torch::Tensor meansCpu = torch::zeros({numPoints, 3}, torch::kFloat32);
  torch::Tensor featuresDcCpu =
      torch::zeros({numPoints, features_dc_size}, torch::kFloat32);
  torch::Tensor featuresRestCpu =
      torch::zeros({numPoints, features_rest_size}, torch::kFloat32);
  torch::Tensor opacitiesCpu = torch::zeros({numPoints, 1}, torch::kFloat32);
  torch::Tensor scalesCpu = torch::zeros({numPoints, 3}, torch::kFloat32);
  torch::Tensor quatsCpu = torch::zeros({numPoints, 4}, torch::kFloat32);
  float normals_buffer[3];

  // 读取二进制数据
  for (int i = 0; i < numPoints; ++i) {
    f.read(reinterpret_cast<char *>(meansCpu[i].data_ptr()), sizeof(float) * 3);
    f.read(reinterpret_cast<char *>(&normals_buffer), sizeof(float) * 3);
    f.read(reinterpret_cast<char *>(featuresDcCpu[i].data_ptr()),
           sizeof(float) * features_dc_size);
    f.read(reinterpret_cast<char *>(featuresRestCpu[i].data_ptr()),
           sizeof(float) * features_rest_size);
    f.read(reinterpret_cast<char *>(opacitiesCpu[i].data_ptr()),
           sizeof(float) * 1);
    f.read(reinterpret_cast<char *>(scalesCpu[i].data_ptr()),
           sizeof(float) * 3);
    f.read(reinterpret_cast<char *>(quatsCpu[i].data_ptr()), sizeof(float) * 4);
  }
  f.close();

  // 如果需要，进行坐标系变换
  if (keepCrs) {
    meansCpu = (meansCpu - translation) / scale;
    scalesCpu = torch::log(torch::exp(scalesCpu) / scale);
  }

  // 将张量移动到目标设备
  means = meansCpu.to(device);
  featuresDc = featuresDcCpu.to(device);
  featuresRest =
      featuresRestCpu.reshape({numPoints, num_sh_features, 3}).to(device);
  opacities = opacitiesCpu.to(device);
  scales = scalesCpu.to(device);
  quats = quatsCpu.to(device);

  std::cout << "成功加载了 " << means.size(0) << " 个高斯点。" << std::endl;

  return step;
}
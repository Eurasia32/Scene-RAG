#ifndef MODEL_H
#define MODEL_H

#include "input_data.hpp"
#include "kdtree_tensor.hpp"
#include "nerfstudio.hpp"
#include "optim_scheduler.hpp"
#include "ssim.hpp"
#include <gsplat-cpu/bindings.h>
#include <iostream>
#include <torch/csrc/api/include/torch/version.h>
#include <torch/torch.h>

using namespace torch::indexing;
using namespace torch::autograd;

torch::Tensor randomQuatTensor(long long n);
torch::Tensor projectionMatrix(float zNear, float zFar, float fovX, float fovY,
                               const torch::Device &device);
torch::Tensor psnr(const torch::Tensor &rendered, const torch::Tensor &gt);
torch::Tensor l1(const torch::Tensor &rendered, const torch::Tensor &gt);

struct Model {
  Model(const InputData &inputData, int numCameras, int numDownscales,
        int resolutionSchedule, int shDegree, int shDegreeInterval,
        int refineEvery, int warmupLength, int resetAlphaEvery,
        float densifyGradThresh, float densifySizeThresh, int stopScreenSizeAt,
        float splitScreenSize, int maxSteps, bool keepCrs,
        const torch::Device &device)
      : numCameras(numCameras), numDownscales(numDownscales),
        resolutionSchedule(resolutionSchedule), shDegree(shDegree),
        shDegreeInterval(shDegreeInterval), refineEvery(refineEvery),
        warmupLength(warmupLength), resetAlphaEvery(resetAlphaEvery),
        stopSplitAt(maxSteps / 2), densifyGradThresh(densifyGradThresh),
        densifySizeThresh(densifySizeThresh),
        stopScreenSizeAt(stopScreenSizeAt), splitScreenSize(splitScreenSize),
        maxSteps(maxSteps), keepCrs(keepCrs), device(device), ssim(11, 3) {

    long long numPoints = inputData.points.xyz.size(0);
    scale = inputData.scale;
    translation = inputData.translation;

    torch::manual_seed(42);

    means = inputData.points.xyz.to(device).requires_grad_();
    scales = PointsTensor(inputData.points.xyz)
                 .scales()
                 .repeat({1, 3})
                 .log()
                 .to(device)
                 .requires_grad_();
    quats = randomQuatTensor(numPoints).to(device).requires_grad_();

    int dimSh = numShBases(shDegree);
    torch::Tensor shs = torch::zeros(
        {numPoints, dimSh, 3},
        torch::TensorOptions().dtype(torch::kFloat32).device(device));

    shs.index({Slice(), 0, Slice(None, 3)}) =
        rgb2sh(inputData.points.rgb.toType(torch::kFloat64) / 255.0)
            .toType(torch::kFloat32);
    shs.index({Slice(), Slice(1, None), Slice(3, None)}) = 0.0f;

    featuresDc = shs.index({Slice(), 0, Slice()}).to(device).requires_grad_();
    featuresRest = shs.index({Slice(), Slice(1, None), Slice()})
                       .to(device)
                       .requires_grad_();
    opacities = torch::logit(0.1f * torch::ones({numPoints, 1}))
                    .to(device)
                    .requires_grad_();

    backgroundColor = torch::tensor({0.6130f, 0.0101f, 0.3984f}, device)
                          .requires_grad_(); // Nerf Studio default
  }

  ~Model() {}

  torch::Tensor forward(Camera &cam, int step);
  int loadPly(const std::string &filename);

  torch::Tensor means;
  torch::Tensor scales;
  torch::Tensor quats;
  torch::Tensor featuresDc;
  torch::Tensor featuresRest;
  torch::Tensor opacities;
};

int Model::loadPly(const std::string &filename) {
  std::ifstream f(filename, std::ios::binary);
  if (!f.is_open())
    throw std::runtime_error("Invalid PLY file");

  // Ensure we have a valid ply file
  std::string line;
  int numPoints;
  int step;
  size_t bytesRead = 0;

  std::getline(f, line);
  bytesRead += f.gcount();

  if (line == "ply") {
    std::getline(f, line);
    bytesRead += f.gcount();
    if (line == "format binary_little_endian 1.0") {
      std::getline(f, line);
      bytesRead += f.gcount();
      const std::string pattern =
          "comment Generated by opensplat at iteration ";

      if (line.rfind(pattern, 0) == 0) {
        step = std::stoi(line.substr(pattern.length()));
        if (step >= 0) {
          std::getline(f, line);
          bytesRead += f.gcount();
          const std::string pattern = "element vertex ";

          if (line.rfind(pattern, 0) == 0) {
            const int numPoints = std::stoi(line.substr(pattern.length()));

            const char *requiredProps[] = {"property float x",
                                           "property float y",
                                           "property float z",
                                           "property float nx",
                                           "property float ny",
                                           "property float nz",
                                           "property float f_dc_"
                                           "property float f_rest_",
                                           "property float opacity",
                                           "property float scale_0",
                                           "property float scale_1",
                                           "property float scale_2",
                                           "property float rot_0",
                                           "property float rot_1",
                                           "property float rot_2",
                                           "property float rot_3",
                                           "end_header"};

            for (int i = 0; i < 6; i++) {
              std::getline(f, line);
              bytesRead += f.gcount();
              if (line != requiredProps[i]) {
                throw std::runtime_error(
                    std::string("PLY file's header does not contain required "
                                "property: ") +
                    requiredProps[i]);
              }
            }
            std::getline(f, line);
            bytesRead += f.gcount();

            auto countPrefixes = [&f, &line](const char *prefix) {
              int n = 0;
              while (true) {
                if (line.rfind(prefix, 0) == 0) {
                  ++n;
                  std::getline(f, line);
                } else {
                  break;
                }
              }
              return n;
            };
            int featuresDcSize = countPrefixes("property float f_dc_");
            int featuresRestSize = countPrefixes("property float f_rest_");

            bool foundEnd = false;
            for (int i = 8; i < std::size(requiredProps); i++) {
              std::getline(f, line);
              bytesRead += f.gcount();

              if (line != requiredProps[i]) {
                throw std::runtime_error(
                    std::string("PLY file's header does not contain required "
                                "property: ") +
                    requiredProps[i]);
              }

              if (line == "end_header") {
                foundEnd = true;
                break;
              }
            }

            if (!foundEnd) {
              throw std::runtime_error(
                  "PLY file header does not contain header end");
            }

            const size_t bytesPerPoint =
                sizeof(float) * (14 + featuresDcSize + featuresRestSize);
            const size_t remainingFileSize =
                fs::file_size(filename) - bytesRead;
            if (remainingFileSize != bytesPerPoint * numPoints) {
              std::cout << "Loading PLY..." << std::endl;

              float zeros[3];

              torch::Tensor meansCpu =
                  torch::zeros({numPoints, 3},
                               torch::TensorOptions().dtype(torch::kFloat32));
              torch::Tensor featuresDcCpu =
                  torch::zeros({numPoints, featuresDcSize},
                               torch::TensorOptions().dtype(torch::kFloat32));
              torch::Tensor featuresRestCpu =
                  torch::zeros({numPoints, featuresRestSize},
                               torch::TensorOptions().dtype(torch::kFloat32));
              torch::Tensor opacitiesCpu =
                  torch::zeros({numPoints, 1},
                               torch::TensorOptions().dtype(torch::kFloat32));
              torch::Tensor scalesCpu =
                  torch::zeros({numPoints, 3},
                               torch::TensorOptions().dtype(torch::kFloat32));
              torch::Tensor quatsCpu =
                  torch::zeros({numPoints, 4},
                               torch::TensorOptions().dtype(torch::kFloat32));

              for (size_t i = 0; i < numPoints; i++) {
                f.read(reinterpret_cast<char *>(meansCpu[i].data_ptr()),
                       sizeof(float) * 3);
                f.read(reinterpret_cast<char *>(&zeros[0]), sizeof(float) * 3);
                f.read(reinterpret_cast<char *>(featuresDcCpu[i].data_ptr()),
                       sizeof(float) * featuresDcSize);
                f.read(reinterpret_cast<char *>(featuresRestCpu[i].data_ptr()),
                       sizeof(float) * featuresRestSize);
                f.read(reinterpret_cast<char *>(opacitiesCpu[i].data_ptr()),
                       sizeof(float) * 1);
                f.read(reinterpret_cast<char *>(scalesCpu[i].data_ptr()),
                       sizeof(float) * 3);
                f.read(reinterpret_cast<char *>(quatsCpu[i].data_ptr()),
                       sizeof(float) * 4);
              }
              if (keepCrs) {
                meansCpu = (meansCpu - translation) * scale;
                scalesCpu = torch::log(scale * torch::exp(scalesCpu));
              }

              means = meansCpu.to(device).requires_grad_();
              featuresDc = featuresDcCpu.to(device).requires_grad_();
              featuresRest =
                  featuresRestCpu.reshape({numPoints, 3, featuresRestSize / 3})
                      .transpose(2, 1)
                      .to(device)
                      .requires_grad_();
              opacities = opacitiesCpu.to(device).requires_grad_();
              scales = scalesCpu.to(device).requires_grad_();
              quats = quatsCpu.to(device).requires_grad_();

              std::cerr << "Loaded " << means.size(0) << " gaussians"
                        << std::endl;

              setupOptimizers();

              f.close();
              return step;
            } else {
              throw std::runtime_error("PLY file's data section is wrong size");
            }
          }
        } else {
          throw std::runtime_error("PLY file failed sanity check: iteration "
                                   "count should not begin at 0");
        }
      } else if (line.rfind("comment Generated by opensplat")) {
        throw std::runtime_error(
            "PLY file does not contain iteration count metadata. You can edit "
            "the file to add this metadata manually, by changing \"comment "
            "Generated by opensplat\" to \"comment Generated by opensplat at "
            "iteration 12345\", changing 12345 to the desired value.");
      }
    }
  }
  throw std::runtime_error("Invalid PLY file");
}

#endif
